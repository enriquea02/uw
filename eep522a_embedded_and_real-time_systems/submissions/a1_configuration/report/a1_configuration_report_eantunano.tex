\documentclass[journal]{IEEEtran}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
% Path is relative to a1_configuration_report_eantunano.tex
\graphicspath{ {./images/}}

\begin{document}

    \title{Raspberry Pi 4 Embedded Development Environment}

    \author{Enrique~Antunano\\University~of~Washington\\enriantu@uw.edu\\https://github.com/enriquea02/uw}

    \markboth{EEP522A~Embedded and~Real~Time~Systems, A1~Configuration, January~2025}{}

    \maketitle

    \begin{abstract}
        The purpose of the A1 Configuration assignment is to set up the Raspberry Pi 4 and the embedded development environment that will be used to interact with the machine. 
        Creating an embedded development environment involves setting up the hardware and software.
        The goal will be to have a headless system for the Raspberry Pi 4, using SSH from a host machine to interface with the Raspberry Pi 4 device.

    \end{abstract}
    \section{Introduction}
    The objective of this project is to configure an embedded development environment for the Raspberry Pi. 
    Creating an embedded development environment involves setting up the hardware and software. 
    At the end of the project, a host machine should be able to SSH into the Raspberry Pi that has a Raspberry Pi OS image, transfer files, and the Raspberry Pi should be able to locally compile and run a basic device characterization test.
    From my estimate, the project should take 3-4 hours. Additional time was spent attempting to configure my host machine's environment to make a conducive embedded development environment.

    \section{Methods}
    To setup, verify, and characterize a new Raspberry Pi, first follow the step-by-step setup and verification instructions for a headless system listed under Appendix A. 
    Appendix A also includes a material checklist for everything you should need to perform initial setup and verification.
    Additionally, before proceeding, the reader should review \emph{Getting Started - Raspberry Pi Documentation}.

    \begin{enumerate}
        \item Material checklist
        \item Raspberry Pi Imager
        \item Raspberry Pi 4 Initial Turn On and OS boot
        \item SSH into Raspberry Pi 4
        \item Configure Raspberry Pi OS Bullseye Debian
        \item Update and Upgrade Raspberry Pi system
        \item Install GNU Plot
        \item Verification of Raspberry Pi after System Setup
    \end{enumerate}

    Once all the Appendix A subsections have been completed in order, refer to the instructions below to perform basic device characterization.

    Basic Raspberry Pi 4 characterization was conducted using a set of scripts found within the \emph{ee\_course.zip} that was provided by Dr. Sloss. 
    The characterization script runs the same set of three tests 500 times, meaning the type of test remains consistent across each test iteration.
    The three tests run are a memory write test, a memory-friendly matrix calculation, and a memory-unfriendly matrix calculation.

    To run the characterization script on the Raspberry Pi 4, first the zip folder should be transferred into the Raspberry Pi 4 into a new directory called \emph{experiment}.
    With \emph{Visual Studio Code}, the zip folder can be dragged and dropped from the host machine into the Raspberry Pi 4 after an SSH connection to the embedded device has been set up within Visual Studio Code.
    Once the zip file is transferred into the Raspberry Pi 4's new \emph{experiment} directory, unzip the folder. \newline

    Use the following commands within the Visual Studio Code terminal to unzip the folder.

    \begin{lstlisting}[frame=single]
        unzip ee_course.zip
    \end{lstlisting}

    After unzipping the \emph{ee\_course.zip}, you will find multiple files. 
    The \emph{prototype.c} file supports characterization of the Raspberry Pi 4 (4G) model. 
    The plot\_1/2/3 files all take the \emph{.dat} files generated by the \emph{prototype.c} and plot its data using \emph{gnuplot}.
    Finally, the \emph{run.sh} file is a Unix shell script that controls the top-level flow of the characterization tools. 
    The shell script flow is as follows: it cleans the working directory (/experiment), compiles \emph{prototype.c}, runs the compiled script, then calls the plot scripts to graph the data.
    To run the shell script, which launches the Raspberry Pi 4 characterization, go to your \emph{experiment} directory and use the command below in the Visual Studio Code SSH terminal to the Raspberry Pi 4.

    \begin{lstlisting}[frame=single]
        ./run.sh
    \end{lstlisting}

    After unzipping the \emph{ee\_course.zip} and running the shell script in the Visual Studio Code SSH terminal to the Raspberry Pi 4, the script will fail.
    The \emph{prototype.c} script needs the target Raspberry Pi's model information to run. 
    Meaning, in the future, if using a new Raspberry Pi model, follow these steps to collect the device's manufacturer ID (model), memory size, and revision. 
    The first command prints the memory size available on the Raspberry Pi 4.

    \begin{lstlisting}[frame=single]
        df -h
    \end{lstlisting}

    \includegraphics[width=2.5in]{df-h_linux_function.png}

    The second command prints the model and revision information of the Raspberry Pi 4.

    \begin{lstlisting}[frame=single]
        view /proc/cpuinfo
    \end{lstlisting}

    \includegraphics[width=2.5in]{raspberry_pi_model_and_revision.png}

    After gathering the information, append it to the \emph{void prototype\_translate\_information} function inside the \emph{prototype.c} file so that the script can characterize the new Raspberry Pi device without failing.
    To update the script for the Raspberry Pi 4 Model B, the following code was added to the \emph{void prototype\_translate\_information} function inside the \emph{prototype.c} file. 

    \begin{lstlisting}[frame=single]
        if (!strcmp(model,"a03115"))
        {
            g_core.model = 0xa03115;
            g_core.memory_size_gb = 4;
            g_core.revision = 1.5;
            return;
        } 
    \end{lstlisting}

    After updating the script, run it from the terminal. 
    The script will take 5-10 minutes to run. In my experience, with a passive heat sink installed onto the Raspberry Pi 4, the test finished in about 1-2 minutes.
    Once the script finishes its suite of tests, three (3) graphs will be generated within the \emph{experiment} directory.
    These graphs contain the characterization data, covered in the next section.
    Once the characterization data is gathered, I would recommend transferring the updated script back to the host machine, along with the raw data, and the graphs.
    The following command was used to retrieve data through SSH from the Raspberry Pi 4 into the host machine's working directory.

    \begin{lstlisting}[frame=single]
        scp eantunano@raspberrypi4.local:~/experiment/*.dat .
        scp eantunano@raspberrypi4.local:~/experiment/*.jpg .
        scp eantunano@raspberrypi4.local:~/experiment/prototype.c .
    \end{lstlisting}

    \section{Results}
    After running the characterization scripts outlined in the previous section, raw data for CPU time, relative temperature, and relative energy were logged in the \emph{main.dat} and \emph{test.dat} files generated within the \emph{experiments} directory.
    The raw data was transferred onto the host machine and is available on {\href{https://github.com/enriquea02/uw/tree/d529ec8c53c7cc006b5184ab091cdea1d053dabc/eep522a_embedded_and_real-time_systems/submissions/a1_configuration}{github}}, along with the source code.
    Three separate plots were generated from the raw data. Jump down to Appendix B for the Raspberry Pi 4 Model B characterization figures.
    
    Figure 1 plots the test number versus the time to complete a test. The graph separates the data into two, one plot showing time to complete a test when working with memory, and then a second showing time to complete a test when working against memory.
    Figure 2 plots test number versus total elapsed time since script launch, test number versus device temperature relative to the start of the test, and test number versus energy required to complete a test relative to the start of the test. 
    Figure 3 plots the total elapsed time since script launch to complete the test suite. The plot breaks the total elapsed time into chunks of 100 tests until 500 total tests have run through completion.

    In all three graphs, the resources to complete a test (time, energy, and temperature) all trend upwards and to the right with each incremental test iteration.

    The data graphed in Figure 1 shows that friendly memory access functions/calculations take less time to complete than unfriendly memory access functions/calculations at around the 150th test iteration.
    As the test iteration continues to increment, the test completion time of an unfriendly memory access function grows at an exponential rate. 
    In comparison, the time to complete a test for the friendly memory access function grows at a polynomial rate or a lower exponential rate.
    So by the 500th test iteration, it takes approximately .006s longer, or 75\% more time, for the unfriendly function to complete an equivalent task as the friendly function.

    Looking at figure 2, the three values graphed grew linearly, but the rates of growth varied between each metric. 
    The time to complete a test case rose at a slower rate than the estimated energy usage for each successive test conducted. 
    When comparing energy usage to the heat delta from test start, heat generation was growing at a faster rate. 

    The data graphed in figure 3 shows that the first 100 iterations of the test are blazing fast at 5s. 
    Then each successive 100-test iteration takes approximately 10-11 seconds to complete.


    \section{Discussion}
    Before going over the results, I would like to state that using the instructions outlined in the \emph{Methods} section led to a very smooth Rapsberry Pi 4 setup, configuration, and verification with no issues.

    Now, looking over the results, I think it's a fair assumption that under a moderate workload the Raspberry Pi 4 throttles performance as heat increases within the CPU.

    From a quick look at the results from figure 1. I was surprised at how quickly an unfriendly memory access function can slow down performance as heat increases. 
    This makes me think, it is okay to have inefficient functions in the design as long as the device is not stressed for extended periods of time, and it can trend back to a baseline temperature.
    Just looking at the data, differences in performance between the unfriendly function and the friendly function were not noticeable until roughly the 150th test iteration.
    Now, if a function is going to be called repeatedly, or if the device is already stressed, then there begins to be a need for developing more efficient algorithms and functions.

    The second figure is good for when conducting a trade-off analysis. If my main concern were time per test, then I think the current design works fairly well. 
    Time per test did trend upwards and to the right, but it wasn't horrible considering the rapid increase in temperature and power usage.
    Reviewing the data, I am led to think that the system could be pushed for longer and harder, until time per test began to rapidly decline in performance.
    Second observation from the data, energy usage performance degraded over time. It took more energy to complete the same test with each iteration.
    If energy consumption is my main concern, then the design cannot be pushed to heavily, because this will cause energy consumption to rise.
    Final observation on figure 2, temperature rose quickly compared to baseline and did not plateau. 
    Higher temperatures had negative impacts on power usage and performance, so it is key that temperature is managed well by the device.

    The third figure was the least exciting. It showed that the first set of 100 test iterations was very quick. 
    But, due to other factors, which I assume one is temperature, the time to complete a set of 100 test iterations increased to 10-11 seconds.
    Surprisingly, based on results, increasing temperatures did not cause 100-test iteration completion times to increase rapidly past 10-11 seconds.
    If I were to guess, the Raspberry Pi 4 can be pushed harder or for longer before the negative impacts begin to severely impact timing. 

    Future investigation is warranted to determine if the measurable heat dissipation plateaus as a function of Raspberry Pi 4 resource utilization over time. 
    To elaborate, if the Raspberry Pi 4 load resource utilization remained constant but a gambit of $10^{3}$, $10^{4}$, $10^{5}$ test runs were conducted, would the heat, power, and performance trends continue on their trajectories. 
    Additionally, it would be interesting to measure the rate of change of their performances as a function of heat to determine if energy and performance degradation follows a linear or non-linear trend as a function of device heat.

    \section{Conclusion}

    The main objective of this project was to become comfortable configuring a Raspberry Pi 4 and learn how to set it up as a headless device.
    Regarding configuration of the Raspberry Pi 4, the project walked through creating an OS image, pre-configuring the image, flashing the OS onto the device, upgrading applications, and finally setting up the user space. 
    As part of the OS pre-configuration, SSH was enabled, hostname set, username and password set, Wi-Fi name and password set, which allowed the Raspberry Pi 4 to run as a headless system immediately after loading its Raspberry Pi OS Bullseye debian.
    After device setup, the next step was to verify that the Raspberry Pi OS could receive files over SSH from a host Linux machine. 
    Then, verifying the source files could be compiled and run locally on the Raspberry Pi.
    The \emph{C} application that was run on the Raspberry Pi 4 provided baseline characterization of the device regarding power usage, heat dissipation, and performance. 
    Characterization was conducted by stress testing the Raspberry Pi 4 with a standard set up tests which were repeated 500 times.
    Based on the captured data, the Raspberry Pi 4's performance and energy usage degrade with respect to heat, meaning that heat management is a key limitation in the device.
    Future projects on the device will have to factor performance, heat management, and power usage depending on the intended application.

    \nocite{*}
    \newpage

    \bibliographystyle{ieeetr}
    \bibliography{a1_configuration_citations.bib}

    \newpage
    \section{Acknowledgements}
    The author would like to thank the University of Washington Electrical and Computer Engineering Department for providing Raspberry Pi kits.
    
    The author would like to thank Dr. Sloss for the characterization scripts used for this project.

    The author would like to thank IEEE for providing the LaTeX template used in this document and Michael Shell of the Georgia Institute of Technology for putting together the template.

    \appendices
    \section{Install OS onto Raspberry Pi 4}
    \subsection{Material checklist}        
    \begin{itemize}
        \item Linux machine that can store the OS image onto microSD card \newline
            \emph{Distribution: POP!\_OS 22.04 LTS (Debian)}
        \item SD card reader
        \item Minimum 16GB microSD card
        \item Raspberry Pi 4 Model B board
        \item Raspberry Pi compatible power supply
        \item Wireless router
        \item VS Code
        \item VS Code Remote - SSH by Microsoft extension
    \end{itemize}

    \subsection{Raspberry Pi Imager}

    The Raspberry Pi Imager assists with installing the OS onto a storage device, which can then be installed onto the Raspberry Pi 4.

    \begin{enumerate}    
        \item Install the Raspberry Pi Imager from the Linux terminal \newline
        
        Type out the command below and hit \emph{Enter}. \newline

        \begin{lstlisting}[frame=single]
            sudo apt install rpi-imager
        \end{lstlisting}

        \emph{NOTE: POP!\_OS 22.04 LTS includes the Raspberry Pi Imager in its package manager. The package manager has Raspberry Pi Imager v1.7.2, which these instructions will use. If your machine's OS does not include the Raspberry Pi Imager in its package manager, then install the {\href{https://www.raspberrypi.com/software/}{Raspberry Pi Imager}}.} \newline

        Following the figure below, select \emph{y} when prompted. \newline

        \includegraphics[width=2.5in]{sudo_apt_install_rpi_imager.png}

        After selecting \emph{y}, the terminal window should match the figure below after installation has completed. \newline

        \includegraphics[width=2.5in]{sudo_apt_install_rpi_imager_download_progress.png}

        \item Run Raspberry Pi Imager by opening a Linux terminal, typing the following, and selecting \emph{Enter}
        
        \begin{lstlisting}[frame=single]
            rpi-imager
        \end{lstlisting}

        \item Select \emph{CHOOSE OS}

        \includegraphics[width=2.5in]{choose_os.png}
        
        \item Select \emph{Raspberry Pi OS (Legacy,32-bit)}
        
        \includegraphics[width=2.5in]{os_available.png} \newline

        A close-up figure  of the debian that will be installed onto the microSD card. \newline

        \includegraphics[width=2.5in]{rp_os_debian_bullseye.png}
        
        \item Plug-in microSD card into the SD card reader
        \item Plug-in SD card reader into Linux machine

        \item Select \emph{CHOOSE STORAGE}
        
        \includegraphics[width=2.5in]{choose_storage.png}
        
        \item Select storage media. \newline
        HeydayCardReader was my SD card reader. \newline
        31.9 GB represents the size of the microSD card

        \includegraphics[width=2.5in]{sd_card_reader_name.png}

        \item Select the storage icon at the bottom-right of the screen \newline
        
        The Raspberry Pi OS image will be configured here to ease setup on the Raspberry Pi 4

        \includegraphics[width=2.5in]{choose_settings_icon.png}

        The following advanced options screen will appear. \newline

        \includegraphics[width=2.5in]{advanced_options_initial_screen.png}

        \item Set the hostname to be \emph{raspberrypi4}
        \item Select the \emph{Enable SSH} option and select \emph{Use password authentication}
        \item Select the \emph{Set username and password} option and fill in a \emph{username} and \emph{password} of your choosing.
        
        \includegraphics[width=2.5in]{advanced_options_hostname_enable-ssh_user_pass.png}

        \item Select the \emph{Configure wireless LAN} option and fill out the \emph{SSID} and \emph{Password}
        
        \item Select \emph{Set locale settings} and set \emph{Time Zone} to your local time and the \emph{keyboard layout} to your preferred layout
        
        \includegraphics[width=2.5in]{advanced_options_ssid_locale.png}

        \item Select \emph{Play sound when finished} and leave the other two options as enabled. Finally, select \emph{Save}.
        
        \includegraphics[width=2.5in]{advanced_options_misc_settings.png}

        \item Select \emph{WRITE} 
        
        \includegraphics[width=2.5in]{choose_settings_icon.png}

        \item Select \emph{YES} when prompted to continue despite all the data on the microSD card being erased.
        
        \includegraphics[width=2.5in]{clear_sd_card_warning.png}

        \item Type in password when asked to authenticate user
        
        \includegraphics[width=2.5in]{authenticate_password.png}

        \item Wait for SD write to completed
        
        \includegraphics[width=2.5in]{sd_card_write.png}

        \item Wait for SD write verification to completed
        
        \includegraphics[width=2.5in]{sd_card_verify.png}

        \item Click \emph{continue}. The following message will appear after the SD card has successfully been programmed with the Raspberry OS Bullseye debian.
        
        \includegraphics[width=2.5in]{end_write_message.png}

        \item Safely eject your SD card reader from the Linux machine 

    \end{enumerate}

    \subsection{Raspberry Pi 4 Initial Turn On and OS boot}

    The Raspberry Pi 4 setup involves the steps required to boot up the Raspberry Pi OS Bullseye debian onto the Raspberry Pi 4 Model B board.

    \emph{NOTE: The Raspberry Pi 4 should be OFF at the beginning of this section.} \newline


    \begin{enumerate}
        \item Insert the microSD card into the Raspberry Pi's microSD slot on the underside of the board. \newline 
        
        The Raspberry Pi 4 will look for an OS within a microSD card if there is a card inserted in the SD slot. \newline

        \includegraphics[width=2.5in]{sd_card_w_rpi4.png}

        \item Connect the power supply to the Raspberry Pi 4 \newline
        
        \includegraphics[width=2.5in]{rpi4_power_in_cord.png}

        \item Turn on power supply switch. \newline
        
        LEDs on the Raspberry Pi 4 should be enabled \newline

        Leave the Rapsberry Pi 4 alone for 5-10 minutes as the Raspberry Pi 4 OS Bullseye debian is loaded onto the board.

    \end{enumerate}

    \subsection{SSH into Raspberry Pi 4}

    \emph{NOTE: Assuming all the steps were executed without any issue during the \textbf{Raspberry Pi Imager} section, there should be no issue using SSH immediately after the Raspberry Pi 4 has been loaded with an OS after initial power-on.} \newline

    \begin{enumerate}
        \item Open VS Code and go to Remote Explorer \newline
        
        User must download the \emph{Remote - SSH} extension by Microsoft from the VS Code marketplace so that the Remote Explorer shortcut is available. \newline

        \item Select \emph{New Remote} in the SSH Explorer window \newline
        
        The SSH Explorer window will look like the image below. The \emph{New Remote} will pop-up as a user hovers over SSH. \newline

        \includegraphics[width=2.5in]{ssh_explorer_screen.png}

        \item Write the following information into the \emph{Enter SSH Connection Command} pop-up at the top of the screen, then select \emph{Enter}. \newline
        
        \emph{ssh <raspberry pi 4 username>@<raspberry pi 4 hostname>}.local \newline

        Refer back to the rapsberry pi 4 \emph{username} and \emph{hostname} that you set during the \emph{Raspberry Pi Imager} subsection. \newline

        \includegraphics[width=2.5in]{show_how_to_start_ssh_connection.png}

        \item Select where you would like to store your SSH configuration settings, then select \emph{Enter}
        
        \includegraphics[width=2.5in]{set_ssh_config_to_local_user.png}

        Afterwards, you should be SSH'ed in your Raspberry Pi 4 in headless mode. Congratulations! \newline
        
        \includegraphics[width=2.5in]{ssh_into_raspberrypi4.png}

    \end{enumerate}

    \subsection{Configure Raspberry Pi OS Bullseye Debian}

    This section will focus on configuring your Raspberry Pi OS after initial power on and SSHing into your system. \newline

    \begin{enumerate}
        \item In your VS Code's SSH terminal, type the following and then hit \emph{Enter}
        
        \begin{lstlisting}[frame=single]
            sudo raspi-config
        \end{lstlisting}

        The following screen will appear across your VS Code SSH terminal. \newline

        \includegraphics[width=2.5in]{rpi_sw_config_tool_home.png}

        \item Select \emph{1 System Options} from the home screen

        \item A new menu will appear. Go down the menu and select the \emph{S5 Boot / Auto Login}
        
        \includegraphics[width=2.5in]{rpi_sw_config_tool_boot_auto_login.png}

        \item Select option \emph{B2 Console Autologin}
        
        \includegraphics[width=2.5in]{rpi_sw_config_tool_subscreen_console_auto_login.png}

        \item You'll be taken back to the home screen. Select \emph{1 System Options} from the home screen

        \item Next go down the menu and select \emph{S7 Splash Screen}
        
        \includegraphics[width=2.5in]{rpi_sw_config_tool_splash_screen.png}

        \item Select \emph{No}
        
        \includegraphics[width=2.5in]{rpi_sw_config_tool_splash_screen_yes_no.png}

        The next screen will notify you that the splash screen has been disabled. \newline

        \includegraphics[width=2.5in]{rpi_sw_config_tool_splash_screen_disabled.png}

        \item You'll be taken back to the home screen. Select \emph{2 Display Options} from the home screen
        
        \item Next go down to and select \emph{D5 VNC Resolution}
        
        \includegraphics[width=2.5in]{rpi_sw_config_tool_subscreen_vnc_resolution.png}
        
        \item Select \emph{1920x1080}
        
        \includegraphics[width=2.5in]{rpi_sw_config_tool_vnc_1920x1080.png}

        The next screen will notify you that the resolution has been set to 1920x1080. Select OK.

        \includegraphics[width=2.5in]{rpi_sw_config_tool_vnc_1920_1080_ok.png}
        
        \item You'll be taken back to the home screen. Select \emph{3 Interface Options} from the home screen

        \item Next go down the menu and select \emph{I3 VNC}
        
        \includegraphics[width=2.5in]{rpi_sw_config_tool_vnc_enable.png}

        \item Select \emph{yes}
        
        \includegraphics[width=2.5in]{rpi_sw_config_tool_vnc_enable_yes.png}

        The next screen will notify you that the VNC Server is enabled. Select OK.

        \includegraphics[width=2.5in]{rpi_sw_config_tool_vnc_ok.png}

        \item You'll be taken back to the home screen. Select \emph{8 Update} from the home screen

        \item Select \emph{yes} so the Rapsberry Pi system can reboot
        
        \includegraphics[width=2.5in]{rpi_sw_config_tool_update_yes.png}

        \emph{NOTE: The following error will appear on your VS Code SSH terminal since the Raspberry Pi 4 has been rebooted. \newline RECOMMENDATION: Close VS Code and open a new SSH instance after 1-2 minutes from reboot.} \newline

        \includegraphics[width=2.5in]{vs_code_ssh_offline_error.png}

    \end{enumerate}

    \subsection{Update and Upgrade Raspberry Pi System}

    This section covers how to update and upgrade the OS image on the Raspberry Pi so that it has the latest files.

    \begin{enumerate}
        \item Type the code below to update the software, so that the system has the latest list of current available software
        
        \begin{lstlisting}[frame=single]
            sudo apt-get update
        \end{lstlisting}
        
        \includegraphics[width=2.5in]{update_software_on_pi4.png}

        \item Type the code below in the Raspberry Pi terminal, over SSH, and then type \emph{y} when prompted by the upgrade script.
        
        \begin{lstlisting}[frame=single]
            sudo apt-get upgrade
        \end{lstlisting}
        
        Upgrade will install the latest software that was pulled from the previous update command. \newline 

        \includegraphics[width=2.5in]{upgrade_software_on_rpi4.png}

    \end{enumerate}

    \subsection{Install GNU Plot}

    This section covers how to install \emph{GNU Plot} for use with the \emph{ee\_course.zip} project. \newline

    \begin{enumerate}
        \item Type the code below in the Raspberry Pi terminal, over SSH, and then type \emph{y} when prompted by the install script.
        
        \begin{lstlisting}[frame=single]
            sudo apt install gnuplot
        \end{lstlisting}

        \includegraphics[width=2.5in]{gnu_plot_install.png}

    \end{enumerate}

    \subsection{Verification of Raspberry Pi after System Setup}
    After system setup, the Raspberry Pi 4 was verified using a \emph{hello world} c-script. The code below was compiled and remotely run on the Raspberry Pi 4 through a host Linux machine.

    \begin{lstlisting}[frame=single]
        # include <stdio.h>

        int main(void)
        {
            printf("hello_world\n");
            return 1;
        }   
    \end{lstlisting}

    The script was compiled on the Raspberry Pi 4 through two methods, to explore how c-code compilation on the device. \newline

    The following text was written in the terminal to compile a file called \emph{a.out} \newline

    \begin{lstlisting}[frame=single]
        cc hello.c
    \end{lstlisting}

    \includegraphics[width=2.5in]{a_out_hello_world.png}

    Afterwards, the following text was written in the terminal to compile a file called \emph{hellow} \newline

    \begin{lstlisting}[frame=single]
        gcc hello.c -o hellow
    \end{lstlisting}
    
    \includegraphics[width=2.5in]{hellow_hello_world.png}

    \section{Figures and Tables}
    \subsection{Figure 1 Memory Subsystems}

    \includegraphics[width=2.5in]{plot_memsys.jpg}

    \subsection{Figure 2 Memory Library Tests (time, rel. temp., rel. energy)}

    \includegraphics[width=2.5in]{plot_memlib.jpg}

    \subsection{Figure 3 Total Time to Run Tests}

    \includegraphics[width=2.5in]{plot_tests.jpg}

\end{document}